---
title: "Power analysis Helmut's Nature Ecol Evol paper"
author: "Yefeng"
date: "2021/4/13"
output: html_document
subtitle: "check for Shinichi"
---


## Setup

```{r setup, echo = FALSE}
# Tidy
 # rm(list=ls())
 # graphics.off()

# Preparing workspace
knitr::opts_chunk$set(echo = TRUE, include = TRUE)

# Loading packages
pacman::p_load(knitr, # knit markdown
               readxl, 
               readr, 
               metafor, 
               dplyr, 
               tidyverse, 
               janitor, # generate 1-, 2-way table
               patchwork, # layout of plots
               cowplot, 
               ggpubr,
               gridExtra,
               orchaRd, # forest-like plot
               gridGraphics, # Redraw Base Graphics Using 'grid' Graphics. `gridGraphics` is required to handle base-R plots.
               dabestr, # compare differences between groups
               here,
               retrodesign,
               lme4,
               car, # logit transformation, car::logit()
               boot, # Bootstrap Resampling
               lmerTest # get p-valus from lme4 model, but need to re-fit the model lmerTest::lme4
               )

# Function to calculate power (two-tail) for meta-analysis
power.ma_Shinichi <- function(mu, SE, alpha = 0.05) {
  2-pnorm(qnorm(1-alpha/2)-abs(mu)/SE)-pnorm(qnorm(1-alpha/2)+abs(mu)/SE)
  } # or power.ma_Shinichi1 <- function(mu,SE){1 - pnorm(qnorm(1-0.05/2)-abs(mu)/SE) + pnorm(-qnorm(1-0.05/2)-abs(mu)/SE)}



# Function for power analysis for empirical data point
power.individual_Shinichi <- function(mu, se, alpha = 0.05) {
  2-pnorm(qnorm(1-alpha/2)-abs(mu)/se)-pnorm(qnorm(1-alpha/2)+abs(mu)/se)} # two-tailed power


# Function for Type S error for empirical data point

error_S <- function(mu, se, alpha = 0.05){
  #z <- qnorm(1 - alpha/2) # Z-score or quantile
  p.u <- 1 - pnorm(qnorm(1 - alpha/2) - abs(mu)/se) # upper-tail probability
  p.l <- pnorm(-qnorm(1 - alpha/2) - abs(mu)/se) # lower-tail probability
  power <- p.u + p.l # upper + lower
  errorS <- p.l/power # percentage of the opposite direction
  return(errorS)
} 


# Function for Type M error for empirical data point
error_M <- function(mu, se, alpha = 0.05, N = 10000) {
    est.random <- rnorm(n=N, mean = mu, sd = se)
    # est.random <- mu + se*rnorm(n=N, mean=0, sd=1)
    sig.index <- abs(est.random) > se*qnorm(1 - alpha/2)
    overestimate <- mean(abs(est.random)[sig.index])/abs(mu) # ratio is regardnesss of sign, so we need absolute value
    absolute_error <- overestimate*abs(mu) - abs(mu)
    relative_error <- absolute_error/(overestimate*abs(mu))
  return(abs(overestimate) %>% round(3))
}



error_M2 <- function(mu, se, alpha = 0.05, N = 10000) {
    est.random <- rnorm(n=N, mean = mu, sd = se)
    # est.random <- mu + se*rnorm(n=N, mean=0, sd=1)
    sig.index <- abs(est.random) > se*qnorm(1 - alpha/2)
    overestimate <- mean(abs(est.random)[sig.index])/abs(mu) # ratio is regardnesss of sign, so we need absolute value
    absolute_error <- overestimate*abs(mu) - abs(mu)
    relative_error <- absolute_error/(overestimate*abs(mu))
  return(abs(relative_error) %>% round(3))
}


    
# Function for caltulating sampling variance of magnitude    
folded_error <-function(mean, variance){
  mu <- mean
  sigma <- sqrt(variance)
  fold_mu <- sigma*sqrt(2/pi)*exp((-mu^2)/(2*sigma^2)) + mu*(1 - 2*pnorm(-mu/sigma))
  fold_se <- sqrt(mu^2 + sigma^2 - fold_mu^2)
  # adding se to make bigger mean
  fold_v <-fold_se^2
  fold_v
}
    
```




### 1. Fit multi-level meta-analytic models for lnrr 

We first ran multi-level meta-analytic models for lnrr. This was used for replacement of bia-corrected models which are in wrong direction of slopes

```{r}
# load required data
load(here("data","lnrr.RData")) # data list for lnrr
load(here("data","model_est_lnrr.RData")) # (original) meta-analytic overall mean for lnrr

# cope a list
dat_list_adjusted_lnrr <- lnrr


# fit multi-level meta-analytic models - will use some of these models to replace bia-corrected models which are in wrong direction of slope
model_list_lnrr <- NA
for (i in 1:12) {
 model_list_lnrr[i] <- rma.mv(data = lnrr[[i]], yi = yi, V = vi, random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}

```




### 2. Adjusted lnrr based on effective sample size

This section got adjusted lnrr by modeling 'effective N'

When we get adjusted lnrr, two things need to notice:
(1) two-stage approach: using PET’s intercept ('SE' as moderator) when slope is not sig, but PEEESE’s intercept (variance or 'SE^2' as moderator) if PET’s slope is sig
(2) wrong direction of slope: some meta-analyses do not show correct direction. In such case, we use original estimate (without correction) to replace them

#### 2.1 Get adjusted-lnrr (effective N version)

Fit two-stage models and find meta-analyses with correct direction

```{r}

#----------------------------------------------------------------#
#              first-stage: using PET to model 'SE'                #
#----------------------------------------------------------------#

# creating a varible for the "effective sample size" to account for unbalanced sampling
# function to calculate effective sample size
esz <- function(dat){(4*dat$C_N*dat$T_N) / (dat$C_N + dat$T_N)}

 
esz_lnrr <- NA
for (i in 1:length(lnrr)) {
  esz_lnrr[i] <- esz(lnrr[[i]]) %>% list()}

# allocate each set of effective sample size into corresponding dataset
for (i in 1:length(lnrr)) {
  lnrr[[i]]$esz_lnrr <- esz_lnrr[[i]]
}
 

# creating inverse of sqrt of effective sample size - "effective sample size" based "sampling variance" 
## function to calculate inverse of sqrt of effective sample size
esz.var <- function(dat){ 1/dat$C_N + 1/dat$T_N}
esz.var_lnrr <- NA
for (i in 1:length(lnrr)) {
  esz.var_lnrr[i] <- esz.var(lnrr[[i]]) %>% list()}

# allocate into corresponding dataset
for (i in 1:length(lnrr)) {
  lnrr[[i]]$esz.var_lnrr <- esz.var_lnrr[[i]]
}


# fit first stage model - inverse of effective sample size as moderator
model_list_PET_PEESE_lnrr.sei.esz <- list() 
for (i in 1:length(lnrr)) {
 model_list_PET_PEESE_lnrr.sei.esz[i] <- rma.mv(data = lnrr[[i]], yi = yi, V = vi, mods = ~ sqrt(esz.var_lnrr),random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}

# get intercepts and slopes for first stage
## intercepts
model_est_PET_PEESE_lnrr.sei.esz.intercept <- data.frame(MA_case=model_est_lnrr$MA_case,
                  mu_lnrr=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$beta[1]),
                  SE_lnrr=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$se[1]),
                  ll_NHST=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$ci.lb[1]),
                  ul_NHST=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$ci.ub[1]),
                  p_value=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$pval)[c(seq(1,24,2))]) # odd columns for intercept's p-value

## slopes
model_est_PET_PEESE_lnrr.sei.esz.slope <- data.frame(MA_case=model_est_lnrr$MA_case,
                  mu_lnrr=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$beta[2]),
                  SE_lnrr=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$se[2]),
                  ll_NHST=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$ci.lb[2]),
                  ul_NHST=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$ci.ub[2]),
                  p_value=sapply(model_list_PET_PEESE_lnrr.sei.esz, function(x) x$pval)[c(seq(2,24,2))]) # even columns for slope's p-value



#----------------------------------------------------------------#
#           second-stage: using PEESE to model 'variance'          #
#----------------------------------------------------------------#

# fit second stage model - sampling variance as moderator
model_list_PET_PEESE_lnrr.var.esz <- list() 
for (i in 1:12) {
 model_list_PET_PEESE_lnrr.var.esz[i] <- rma.mv(data = lnrr[[i]], yi = yi, V = vi, mods = ~ esz.var_lnrr, random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}


# get intercepts and slopes for second stage
## intercepts
model_est_PET_PEESE_lnrr.var.esz.intercept <- data.frame(MA_case=model_est_lnrr$MA_case,
                  mu_lnrr=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$beta[1]),
                  SE_lnrr=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$se[1]),
                  ll_NHST=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$ci.lb[1]),
                  ul_NHST=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$ci.ub[1]),
                  p_value=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$pval)[c(seq(1,24,2))]) # odd columns for intercept's p-value


## slopes
model_est_PET_PEESE_lnrr.var.esz.slope <- data.frame(MA_case=model_est_lnrr$MA_case,
                  mu_lnrr=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$beta[2]),
                  SE_lnrr=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$se[2]),
                  ll_NHST=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$ci.lb[2]),
                  ul_NHST=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$ci.ub[2]),
                  p_value=sapply(model_list_PET_PEESE_lnrr.var.esz, function(x) x$pval)[c(seq(2,24,2))]) # odd columns for slope's p-value




#***************************************************************#
#           find meta-analyses with correct direction           #
#***************************************************************#

# using PET’s intercept ('se' as moderator) when slope is not sig but PEEESE’s intercept ('variance' or 'se^2' as moderator) if PET’s slope is sig
## label for reorder later
model_est_PET_PEESE_lnrr.sei.esz.intercept$id <- c(1:12)
model_est_PET_PEESE_lnrr.sei.esz.slope$id <- c(1:12)
model_est_PET_PEESE_lnrr.var.esz.intercept$id <- c(1:12)
model_est_PET_PEESE_lnrr.var.esz.slope$id <- c(1:12)

## significant slope
model_est_PET_PEESE_lnrr.sei.esz.slope.sig <- model_est_PET_PEESE_lnrr.sei.esz.slope %>% subset(p_value < 0.05) 
## non-significant slope
model_est_PET_PEESE_lnrr.sei.esz.slope.nonsig <- model_est_PET_PEESE_lnrr.sei.esz.slope %>% subset(p_value > 0.05)

## get location of PET's sig slope and non-sig slope, respectively
location.sig <- which(model_est_PET_PEESE_lnrr.sei.esz.slope$p_value < 0.05)
location.nonsig <- which(model_est_PET_PEESE_lnrr.sei.esz.slope$p_value > 0.05)


# get the intercept from PEESE (when PET’s slope is sig) and PET (when PET’s slope is nonsig)
model_est_PET_PEESE_lnrr.esz <- rbind(model_est_PET_PEESE_lnrr.sei.esz.intercept[location.nonsig,],model_est_PET_PEESE_lnrr.var.esz.intercept[location.sig,]) 

# reorder according to the sequences of meta-analyses
model_est_PET_PEESE_lnrr.esz <- model_est_PET_PEESE_lnrr.esz[order(model_est_PET_PEESE_lnrr.esz$id),] 


# obtain absolute values for making paired-comparision plot (see below)
model_est_PET_PEESE_lnrr.esz2 <- model_est_PET_PEESE_lnrr.esz
model_est_PET_PEESE_lnrr.esz2$mu_lnrr <- abs(model_est_PET_PEESE_lnrr.esz$mu_lnrr)

model_est_lnrr2 <- model_est_lnrr
model_est_lnrr2$mu_lnrr <- abs(model_est_lnrr$mu_lnrr)

# using dabestr package to creat a table for paired comparision of meta-analytic overall estimate (MAOM) and bias-corrected estimate (cMAOM)
dummy <- rep("Dummy", 12)
wide.data <- 
  tibble::tibble(
    MAOM = model_est_lnrr2$mu_lnrr,
    cMAOM = model_est_PET_PEESE_lnrr.esz2$mu_lnrr,
    Dummy = dummy, ID = 1:12, MA_case = model_est_PET_PEESE_lnrr.esz2$MA_case)



## find correct direction of slope
include.point <- which((wide.data$cMAOM - wide.data$MAOM)<0)
## table only includes correct data
wide.data3 <- wide.data[include.point,]

## make paired comparision plot 
my.data3 <- 
  wide.data3 %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Dummy, -MA_case)

two.group.paired3 <- 
  my.data3 %>%
  dabest(Group, Measurement, 
         idx = c("MAOM", "cMAOM"), 
         paired = TRUE, id.col = ID)

paired.plot3_lnrr.esz <- two.group.paired3 %>% 
  mean_diff() %>% 
  plot(#rawplot.ylim = c(-2, 1),
       #effsize.ylim = c(-2, 1),
       #rawplot.markersize = 1,
       #rawplot.groupwidth = 0.4,
      rawplot.ylabel = "Meta-analytic estimate (lnrr.esz)",
      effsize.ylabel = "Mean differences (bootstrap resampling)",
      axes.title.fontsize = 14, # default is 14
      palette = c("Dark2")
      )

png(filename = "./Figures/paired.plot3_lnrr.esz.png", width = 5, height = 4, units = "in", type = "windows", res = 400)
paired.plot3_lnrr.esz
dev.off()

```


#### 2.2 Compile datasets for adjusted lnrr

When using 'effective N' as moderator, we had 6 meta-analyses showing the correct direction slope. For the left 6, we used the original meta-analytic overall means


```{r}

# get estimates from bias-corrected models (model_est_PET_PEESE_lnrr) if in a correct direction of slope. Otherwise it should use estimates from original models (model_est_lnrr). 

# view(my.data3) or my.data3$ID can know those from bias-corrected models: 2, 3, 4, 8, 9, 11
# get corresponding estimates
model_est_adjusted_lnrr.esz <- data.frame(MA_case=model_est_PET_PEESE_lnrr.esz$MA_case,
                    mu_lnrr=c(model_est_lnrr$mu_lnrr[1],
                             model_est_PET_PEESE_lnrr.esz$mu_lnrr[2],  # match with the my.data3$ID; also see  3, 4, 8, 9, 11
                             model_est_PET_PEESE_lnrr.esz$mu_lnrr[3], 
                             model_est_PET_PEESE_lnrr.esz$mu_lnrr[4],
                             model_est_lnrr$mu_lnrr[5],
                             model_est_lnrr$mu_lnrr[6],
                             model_est_lnrr$mu_lnrr[7],
                             model_est_PET_PEESE_lnrr.esz$mu_lnrr[8],
                             model_est_PET_PEESE_lnrr.esz$mu_lnrr[9],
                             model_est_lnrr$mu_lnrr[10],
                             model_est_PET_PEESE_lnrr.esz$mu_lnrr[11],
                             model_est_lnrr$mu_lnrr[12]
                            ),
                    
                    SE_lnrr=c(model_est_lnrr$SE_lnrr[1],
                             model_est_PET_PEESE_lnrr.esz$SE_lnrr[2], 
                             model_est_PET_PEESE_lnrr.esz$SE_lnrr[3], 
                             model_est_PET_PEESE_lnrr.esz$SE_lnrr[4],
                             model_est_lnrr$SE_lnrr[5],
                             model_est_lnrr$SE_lnrr[6],
                             model_est_lnrr$SE_lnrr[7],
                             model_est_PET_PEESE_lnrr.esz$SE_lnrr[8],
                             model_est_PET_PEESE_lnrr.esz$SE_lnrr[9],
                             model_est_lnrr$SE_lnrr[10],
                             model_est_PET_PEESE_lnrr.esz$SE_lnrr[11],
                             model_est_lnrr$SE_lnrr[12]
                            ),
                    
                ll_NHST=c(model_est_lnrr$ll_NHST[1],
                             model_est_PET_PEESE_lnrr.esz$ll_NHST[2], 
                             model_est_PET_PEESE_lnrr.esz$ll_NHST[3], 
                             model_est_PET_PEESE_lnrr.esz$ll_NHST[4],
                             model_est_lnrr$ll_NHST[5],
                             model_est_lnrr$ll_NHST[6],
                             model_est_lnrr$ll_NHST[7],
                             model_est_PET_PEESE_lnrr.esz$ll_NHST[8],
                             model_est_PET_PEESE_lnrr.esz$ll_NHST[9],
                             model_est_lnrr$ll_NHST[10],
                             model_est_PET_PEESE_lnrr.esz$ll_NHST[11],
                             model_est_lnrr$ll_NHST[12]
                            ),
                
                  ul_NHST=c(model_est_lnrr$ul_NHST[1],
                             model_est_PET_PEESE_lnrr.esz$ul_NHST[2], 
                             model_est_PET_PEESE_lnrr.esz$ul_NHST[3], 
                             model_est_PET_PEESE_lnrr.esz$ul_NHST[4],
                             model_est_lnrr$ul_NHST[5],
                             model_est_lnrr$ul_NHST[6],
                             model_est_lnrr$ul_NHST[7],
                             model_est_PET_PEESE_lnrr.esz$ul_NHST[8],
                             model_est_PET_PEESE_lnrr.esz$ul_NHST[9],
                             model_est_lnrr$ul_NHST[10],
                             model_est_PET_PEESE_lnrr.esz$ul_NHST[11],
                             model_est_lnrr$ul_NHST[12]
                            ),
                
                  p_value=c(model_est_lnrr$p_value[1],
                             model_est_PET_PEESE_lnrr.esz$p_value[2], 
                             model_est_PET_PEESE_lnrr.esz$p_value[3], 
                             model_est_PET_PEESE_lnrr.esz$p_value[4],
                             model_est_lnrr$p_value[5],
                             model_est_lnrr$p_value[6],
                             model_est_lnrr$p_value[7],
                             model_est_PET_PEESE_lnrr.esz$p_value[8],
                             model_est_PET_PEESE_lnrr.esz$p_value[9],
                             model_est_lnrr$p_value[10],
                             model_est_PET_PEESE_lnrr.esz$p_value[11],
                             model_est_lnrr$p_value[12]
                            )) 

```



#### 2.3 Calculate meta-analysis level power, Type S and M

```{r}



#-----------------------------------------------------------#
#          (1) two-tailed power for meta-analyses
#-----------------------------------------------------------#
model_est_adjusted_lnrr.esz$MA.power <- power.ma_Shinichi(mu=model_est_adjusted_lnrr.esz$mu,SE=model_est_adjusted_lnrr.esz$SE)


#-----------------------------------------------------------#
#            (2) type S error for meta-analyses
#-----------------------------------------------------------#
MA.power.S <- NA
for (i in 1:length(model_est_adjusted_lnrr.esz$MA_case)) {
  MA.power.S[i] <- error_S(mu=model_est_adjusted_lnrr.esz$mu[i],se=model_est_adjusted_lnrr.esz$SE[i],alpha=0.05) %>% unlist()
}

model_est_adjusted_lnrr.esz$MA.power.S <- MA.power.S


#-----------------------------------------------------------#
#   (3) type M error (overestimate ratio) for meta-analyses
#-----------------------------------------------------------#
MA.power.M <- NA
for (i in 1:length(model_est_adjusted_lnrr.esz$MA_case)) {
  MA.power.M[i] <- error_M(mu=model_est_adjusted_lnrr.esz$mu[i],se=model_est_adjusted_lnrr.esz$SE[i],alpha=0.05,N=10000) %>% unlist()
}

model_est_adjusted_lnrr.esz$MA.power.M <- MA.power.M


view(model_est_adjusted_lnrr.esz)

summary(model_est_adjusted_lnrr.esz$MA.power) # the summary indicates that meta-analysis level power is really low in this case
```


#### 2.4 Weighted regression on meta-analysis level data

```{r}

#***************************************************************#
#      estimate overall power for meta-analysis level power     #
#***************************************************************#

# add N and k
N_adjusted_lnrr <- NA
for (i in 1:length(dat_list_adjusted_lnrr)) {
  N_adjusted_lnrr[i] <- dat_list_adjusted_lnrr[[i]]$Study %>% unique() %>% length()
}

k_adjusted_lnrr <- NA
for (i in 1:length(dat_list_adjusted_lnrr)) {
  k_adjusted_lnrr[i] <- dat_list_adjusted_lnrr[[i]]$Unit_ID%>% length()
}

model_est_adjusted_lnrr.esz$k <- k_adjusted_lnrr




#--------------------- (1) two tailed power ---------------------#
# log
MMA_MA_adjusted_lnrr.esz2 <- lm(log(MA.power)~1, weights = k, data = model_est_adjusted_lnrr.esz)
# this is median
MMA_MA_adjusted_lnrr.esz2$coefficients  %>% exp() # only 0.2864142 


#confidence interval of median
confint(MMA_MA_adjusted_lnrr.esz2) %>% exp()


#---------------------- (2) type S error -----------------------#
# log
MMA_MA.S_adjusted_lnrr.esz2 <- lm(log(MA.power.S+0.025) ~ 1, weights = k, data = model_est_adjusted_lnrr.esz) # +0.025(25%) to avoide ln(0) = infinity 
# this is median
MMA_MA.S_adjusted_lnrr.esz2$coefficients %>% exp() - 0.025
confint(MMA_MA.S_adjusted_lnrr.esz2) %>% exp() - 0.025 # if the lower boundary was negative (probably caused by the negative variance), we used 0 to replace it


#-------------- (3) type M error (overestimate ratio) -------------#
# log
MMA_MA.M_adjusted_lnrr.esz2 <- lm(log(MA.power.M)~1, weights = k, data = model_est_adjusted_lnrr.esz)
# this is median
MMA_MA.M_adjusted_lnrr.esz2$coefficients %>% exp() 
#confidence interval of median
confint(MMA_MA.M_adjusted_lnrr.esz2) %>% exp()
```




#### 2.5 Calculate individual level power, Type S and M

```{r}
#***************************************************************#
#      power for individual effect size within meta-analysis    #
#***************************************************************#


#----------------------------------------------------------------#
#           (i) intercept (overall mean) as true effect
#----------------------------------------------------------------#

#--------------------- (1) two tailed power ---------------------#

# lnrr
power.F_adjusted_lnrr <- NA
for (i in 1:length(lnrr)) {
  power.F_adjusted_lnrr[i] <- power.individual_Shinichi(mu=rep(model_est_adjusted_lnrr.esz$mu_lnrr[i], length(lnrr[[i]]$vi)), se=sqrt(lnrr[[i]]$vi)) %>% list()}

# allocate each set of power into corresponding dataset
for (i in 1:length(power.F_adjusted_lnrr)) {
  dat_list_adjusted_lnrr[[i]]$power.F_adjusted_lnrr <- power.F_adjusted_lnrr[[i]]
}


#---------------------- (2) type S error -----------------------#
power.F.S_adjusted_lnrr <- NA
for (i in 1:length(lnrr)) {
  power.F.S_adjusted_lnrr[i] <- mapply(error_S,mu=rep(model_est_adjusted_lnrr.esz$mu_lnrr[i], length(lnrr[[i]]$vi)), se=sqrt(lnrr[[i]]$vi)) %>% list()}

# allocate each set of power into corresponding dataset
for (i in 1:length(power.F.S_adjusted_lnrr)) {
  dat_list_adjusted_lnrr[[i]]$power.F.S_adjusted_lnrr <- power.F.S_adjusted_lnrr[[i]]
}



#---------------- (3) type M error (relative error) --------------#
power.F.M_adjusted_lnrr <- NA
for (i in 1:length(lnrr)) {
  power.F.M_adjusted_lnrr[i] <-mapply(error_M,mu=rep(model_est_adjusted_lnrr.esz$mu_lnrr[i], length(lnrr[[i]]$vi)), se=sqrt(lnrr[[i]]$vi)) %>% list()}

# allocate each set of power into corresponding dataset
for (i in 1:length(power.F.M_adjusted_lnrr)) {
  dat_list_adjusted_lnrr[[i]]$power.F.M_adjusted_lnrr <- power.F.M_adjusted_lnrr[[i]]
}

```



#### 2.6 Mixed effect model on individual level data

```{r}

#----------------------------------------------------------------#
#           (i) intercept (overall mean) as true effect
#----------------------------------------------------------------#

# get study identity
studyID_adjusted_lnrr <- NA
for (i in 1:length(dat_list_adjusted_lnrr)) {
  studyID_adjusted_lnrr[i] <- dat_list_adjusted_lnrr[[i]]$Study %>% list()
}

# unlist data
studyID_adjusted_lnrr <- unlist(studyID_adjusted_lnrr)
power.F_adjusted_lnrr <- unlist(power.F_adjusted_lnrr)
power.F.S_adjusted_lnrr <- unlist(power.F.S_adjusted_lnrr)
power.F.M_adjusted_lnrr <- unlist(power.F.M_adjusted_lnrr)


# combine the dataset for modelling
individual_est_adjusted_lnrr <- data.frame("studyID_adjusted_lnrr" = studyID_adjusted_lnrr,
                                "power.F_adjusted_lnrr" = power.F_adjusted_lnrr,
                                "power.F.S_adjusted_lnrr" = power.F.S_adjusted_lnrr,
                                "power.F.M_adjusted_lnrr" = power.F.M_adjusted_lnrr)


#***************************************************************#
#        estiamte overall power for individual level power      #
#***************************************************************#
#----------------------------------------------------------------#
#           (i) intercept (overall mean) as true effect
#----------------------------------------------------------------#


#--------------------- (1) two tailed power ---------------------#
# log
MMA_power.F_adjusted_lnrr2 <- lmer(log(power.F_adjusted_lnrr) ~ 1 + (1 | studyID_adjusted_lnrr), data = individual_est_adjusted_lnrr)
# this is median 
summary(MMA_power.F_adjusted_lnrr2)$coefficients[1] %>% exp() # higher than meta-analysis level data


#---------------------- (2) type S error -----------------------#
# log
MMA_power.F.S_adjusted_lnrr2 <- lmer(log(power.F.S_adjusted_lnrr + 0.025) ~ 1 + (1 | studyID_adjusted_lnrr), data = individual_est_adjusted_lnrr)
# this is median - and - 0.025 is important
summary(MMA_power.F.S_adjusted_lnrr2)$coefficients[1] %>% exp() - 0.025

#---------------------- (2) type M error -----------------------#

# log
MMA_power.F.M_adjusted_lnrr2 <- lmer(log(power.F.M_adjusted_lnrr) ~ 1 + (1 | studyID_adjusted_lnrr), data = individual_est_adjusted_lnrr)

# this is median
summary(MMA_power.F.M_adjusted_lnrr2)$coefficients[1] %>% exp()


```



