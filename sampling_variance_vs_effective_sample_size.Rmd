---
title: "Power analysis Helmut's Nature Ecol Evol paper"
author: "Yefeng"
date: "2021/4/13"
output: html_document
subtitle: "check for Shinichi"
---


## Setup

```{r setup, echo = FALSE}
# Tidy
 # rm(list=ls())
 # graphics.off()

# Preparing workspace
knitr::opts_chunk$set(echo = TRUE, include = TRUE)

# Loading packages
pacman::p_load(knitr, # knit markdown
               readxl, 
               readr, 
               metafor, 
               dplyr, 
               tidyverse, 
               janitor, # generate 1-, 2-way table
               patchwork, # layout of plots
               cowplot, 
               ggpubr,
               gridExtra,
               orchaRd, # forest-like plot
               gridGraphics, # Redraw Base Graphics Using 'grid' Graphics. `gridGraphics` is required to handle base-R plots.
               dabestr, # compare differences between groups
               here,
               retrodesign,
               lme4,
               car, # logit transformation, car::logit()
               boot, # Bootstrap Resampling
               lmerTest # get p-valus from lme4 model, but need to re-fit the model lmerTest::lme4
               )

# Function to calculate power (two-tail) for meta-analysis
power.ma_Shinichi <- function(mu, SE, alpha = 0.05) {
  2-pnorm(qnorm(1-alpha/2)-abs(mu)/SE)-pnorm(qnorm(1-alpha/2)+abs(mu)/SE)
  } # or power.ma_Shinichi1 <- function(mu,SE){1 - pnorm(qnorm(1-0.05/2)-abs(mu)/SE) + pnorm(-qnorm(1-0.05/2)-abs(mu)/SE)}



# Function for power analysis for empirical data point
power.individual_Shinichi <- function(mu, se, alpha = 0.05) {
  2-pnorm(qnorm(1-alpha/2)-abs(mu)/se)-pnorm(qnorm(1-alpha/2)+abs(mu)/se)} # two-tailed power


# Function for Type S error for empirical data point

error_S <- function(mu, se, alpha = 0.05){
  #z <- qnorm(1 - alpha/2) # Z-score or quantile
  p.u <- 1 - pnorm(qnorm(1 - alpha/2) - abs(mu)/se) # upper-tail probability
  p.l <- pnorm(-qnorm(1 - alpha/2) - abs(mu)/se) # lower-tail probability
  power <- p.u + p.l # upper + lower
  errorS <- p.l/power # percentage of the opposite direction
  return(errorS)
} 


# Function for Type M error for empirical data point
error_M <- function(mu, se, alpha = 0.05, N = 10000) {
    est.random <- rnorm(n=N, mean = mu, sd = se)
    # est.random <- mu + se*rnorm(n=N, mean=0, sd=1)
    sig.index <- abs(est.random) > se*qnorm(1 - alpha/2)
    overestimate <- mean(abs(est.random)[sig.index])/abs(mu) # ratio is regardnesss of sign, so we need absolute value
    absolute_error <- overestimate*abs(mu) - abs(mu)
    relative_error <- absolute_error/(overestimate*abs(mu))
  return(abs(overestimate) %>% round(3))
}



error_M2 <- function(mu, se, alpha = 0.05, N = 10000) {
    est.random <- rnorm(n=N, mean = mu, sd = se)
    # est.random <- mu + se*rnorm(n=N, mean=0, sd=1)
    sig.index <- abs(est.random) > se*qnorm(1 - alpha/2)
    overestimate <- mean(abs(est.random)[sig.index])/abs(mu) # ratio is regardnesss of sign, so we need absolute value
    absolute_error <- overestimate*abs(mu) - abs(mu)
    relative_error <- absolute_error/(overestimate*abs(mu))
  return(abs(relative_error) %>% round(3))
}


    
# Function for caltulating sampling variance of magnitude    
folded_error <-function(mean, variance){
  mu <- mean
  sigma <- sqrt(variance)
  fold_mu <- sigma*sqrt(2/pi)*exp((-mu^2)/(2*sigma^2)) + mu*(1 - 2*pnorm(-mu/sigma))
  fold_se <- sqrt(mu^2 + sigma^2 - fold_mu^2)
  # adding se to make bigger mean
  fold_v <-fold_se^2
  fold_v
}
    
```




### 1. Fit multi-level meta-analytic models for SMD 

We first ran multi-level meta-analytic models for SMD. This was used for replacement of bia-corrected models which are in wrong direction of slope

```{r}
# load required data
load(here("data","SMD.RData")) # data list for SMD
load(here("data","model_est_SMD.RData")) # (original) meta-analytic overall mean for SMD



# fit multi-level meta-analytic models - will use some of these models to replace bia-corrected models which are in wrong direction of slope
model_list_SMD<- NA
for (i in 1:length(dat_list_SMD)) {
 model_list_SMD[i] <- rma.mv(data = SMD[[i]], yi = yi, V = vi, random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}

```



### 2. Adjusted SMD based on sampling variance

This section got adjusted SMD by modeling sampling variance or SE. Section 3 ued effective sample size to get adjusted SMD. The two showed big difference for Type M error.

When we get adjusted SMD, two things need to notice:
(1) two-stage approach: using PET’s intercept (SE as moderator) when slope is not sig, but PEEESE’s intercept (variance or SE^2 as moderator) if PET’s slope is sig
(2) wrong direction of slope: some meta-analyses do not show correct direction

#### 2.1 Estimate adjusted-SMD (sampling variance version)

Fit two-stage models and find meta-analyses with correct direction

```{r}

#***************************************************************#
#                       PET-PEESE approach                      #
#***************************************************************#

#----------------------------------------------------------------#
#              first-stage: using PET to model SE                #
#----------------------------------------------------------------#


# fit first stage model - sampling error as moderator
model_list_PET_PEESE_SMD.sei <- list() 
for (i in 1:length(SMD)) {
 model_list_PET_PEESE_SMD.sei[i] <- rma.mv(data = SMD[[i]], yi = yi, V = vi, mods = ~ sqrt(vi),random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}

# get intercepts and slopes for first stage
## intercepts
model_est_PET_PEESE_SMD.sei.intercept <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$beta[1]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$se[1]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$ci.lb[1]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$ci.ub[1]),
                  p_value=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$pval)[c(seq(1,24,2))]) # odd columns for intercept's p-value

## slopes
model_est_PET_PEESE_SMD.sei.slope <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$beta[2]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$se[2]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$ci.lb[2]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$ci.ub[2]),
                  p_value=sapply(model_list_PET_PEESE_SMD.sei, function(x) x$pval)[c(seq(2,24,2))]) # even columns for slope's p-value



#----------------------------------------------------------------#
#           second-stage: using PEESE to model variance          #
#----------------------------------------------------------------#

# fit second stage model - sampling variance as moderator
model_list_PET_PEESE_SMD.var <- list() 
for (i in 1:12) {
 model_list_PET_PEESE_SMD.var[i] <- rma.mv(data = SMD[[i]], yi = yi, V = vi, mods = ~ vi, random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}


# get intercepts and slopes for second stage
## intercepts
model_est_PET_PEESE_SMD.var.intercept <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.var, function(x) x$beta[1]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.var, function(x) x$se[1]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.var, function(x) x$ci.lb[1]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.var, function(x) x$ci.ub[1]),
                  p_value=sapply(model_list_PET_PEESE_SMD.var, function(x) x$pval)[c(seq(1,24,2))]) # odd columns for intercept's p-value


## slopes
model_est_PET_PEESE_SMD.var.slope <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.var, function(x) x$beta[2]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.var, function(x) x$se[2]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.var, function(x) x$ci.lb[2]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.var, function(x) x$ci.ub[2]),
                  p_value=sapply(model_list_PET_PEESE_SMD.var, function(x) x$pval)[c(seq(2,24,2))]) # odd columns for slope's p-value




#***************************************************************#
#           find meta-analyses with correct direction           #
#***************************************************************#

# using PET’s intercept (se as moderator) when slope is not sig but PEEESE’s intercept (variance or se^2 as moderator) if PET’s slope is sig
## label for reorder later
model_est_PET_PEESE_SMD.sei.intercept$id <- c(1:12)
model_est_PET_PEESE_SMD.sei.slope$id <- c(1:12)
model_est_PET_PEESE_SMD.var.intercept$id <- c(1:12)
model_est_PET_PEESE_SMD.var.slope$id <- c(1:12)

## significant slope
model_est_PET_PEESE_SMD.sei.slope.sig <- model_est_PET_PEESE_SMD.sei.slope %>% subset(p_value < 0.05) 
## non-significant slope
model_est_PET_PEESE_SMD.sei.slope.nonsig <- model_est_PET_PEESE_SMD.sei.slope %>% subset(p_value > 0.05)

## get location of PET's sig slope and non-sig slope, respectively
location.sig <- which(model_est_PET_PEESE_SMD.sei.slope$p_value < 0.05)
location.nonsig <- which(model_est_PET_PEESE_SMD.sei.slope$p_value > 0.05)


# get the intercept from PEESE (when PET’s slope is sig) and PET (when PET’s slope is nonsig)
model_est_PET_PEESE_SMD <- rbind(model_est_PET_PEESE_SMD.sei.intercept[location.nonsig,],model_est_PET_PEESE_SMD.var.intercept[location.sig,]) 

# reorder according to the sequences of meta-analyses
model_est_PET_PEESE_SMD <- model_est_PET_PEESE_SMD[order(model_est_PET_PEESE_SMD$id),] 


# obtain absolute values for making paired-comparision plot (see below)
model_est_PET_PEESE_SMD2 <- model_est_PET_PEESE_SMD
model_est_PET_PEESE_SMD2$mu_SMD <- abs(model_est_PET_PEESE_SMD$mu_SMD)

model_est_SMD2 <- model_est_SMD
model_est_SMD2$mu_SMD <- abs(model_est_SMD$mu_SMD)

# using dabestr package to creat a table for paired comparision of meta-analytic overall estimate (MAOM) and bias-corrected estimate (cMAOM)
dummy <- rep("Dummy", 12)
wide.data <- 
  tibble::tibble(
    MAOM = model_est_SMD2$mu_SMD,
    cMAOM = model_est_PET_PEESE_SMD2$mu_SMD,
    Dummy = dummy, ID = 1:12, MA_case = model_est_PET_PEESE_SMD2$MA_case)

## find correct direction of slope
include.point <- which((wide.data$cMAOM - wide.data$MAOM)<0)
## table only includes correct data
wide.data3 <- wide.data[include.point,]

## make paired comparision plot 
my.data3 <- 
  wide.data3 %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Dummy, -MA_case)

two.group.paired3 <- 
  my.data3 %>%
  dabest(Group, Measurement, 
         idx = c("MAOM", "cMAOM"), 
         paired = TRUE, id.col = ID)

paired.plot3_SMD <- two.group.paired3 %>% 
  mean_diff() %>% 
  plot(#rawplot.ylim = c(-2, 1),
       #effsize.ylim = c(-2, 1),
       #rawplot.markersize = 1,
       #rawplot.groupwidth = 0.4,
      rawplot.ylabel = "Meta-analytic estimate (SMD)",
      effsize.ylabel = "Mean differences (bootstrap resampling)",
      axes.title.fontsize = 14, # default is 14
      palette = c("Dark2")
      )

png(filename = "./Figures/paired.plot3_SMD.png", width = 5, height = 4, units = "in", type = "windows", res = 400)
paired.plot3_SMD
dev.off()

```



#### 2.2 Compile datasets for adjusted SMD

After we find the correction direction of meta-analyses, we can compile dataset for adjusted SMD. This includes two components:
(1) correct direction - estimates meta-analyses showing the correct direction slope
(2) wrong direction: original meta-analysis overall mean 

Note: when using sampling variance (or SE) as moderator, we had 8 meta-analyses showing the correct direction slope. 


```{r}

# get estimates from bias-corrected models (model_est_PET_PEESE_SMD) if in a correct direction of slope. Otherwise it should use estimates from original models (model_est_SMD). 

# view(my.data3) or my.data3$ID can know those from bias-corrected models: 1, 2, 3, 4, 5, 6, 9, 12
# get corresponding estimates
model_est_adjusted_SMD <- data.frame(MA_case=model_est_PET_PEESE_SMD$MA_case,
                    mu_SMD=c(model_est_PET_PEESE_SMD$mu_SMD[1], # match with the my.data3$ID; also see 2, 3, 4, 5, 6, 9, 12
                             model_est_PET_PEESE_SMD$mu_SMD[2], 
                             model_est_PET_PEESE_SMD$mu_SMD[3], 
                             model_est_PET_PEESE_SMD$mu_SMD[4],
                             model_est_PET_PEESE_SMD$mu_SMD[5],
                             model_est_PET_PEESE_SMD$mu_SMD[6],
                             model_est_SMD$mu_SMD[7],
                             model_est_SMD$mu_SMD[8],
                             model_est_PET_PEESE_SMD$mu_SMD[9],
                             model_est_SMD$mu_SMD[10],
                             model_est_SMD$mu_SMD[11],
                             model_est_PET_PEESE_SMD$mu_SMD[12]
                            ),
                    
                    SE_SMD=c(model_est_PET_PEESE_SMD$SE_SMD[1],
                             model_est_PET_PEESE_SMD$SE_SMD[2],
                             model_est_PET_PEESE_SMD$SE_SMD[3],
                             model_est_PET_PEESE_SMD$SE_SMD[4],
                             model_est_PET_PEESE_SMD$SE_SMD[5],
                             model_est_PET_PEESE_SMD$SE_SMD[6],
                             model_est_SMD$SE_SMD[7],
                             model_est_SMD$SE_SMD[8],
                             model_est_PET_PEESE_SMD$SE_SMD[9],
                             model_est_SMD$SE_SMD[10],
                             model_est_SMD$SE_SMD[11],
                             model_est_PET_PEESE_SMD$SE_SMD[12]
                            ),
                    
                ll_NHST=c(model_est_PET_PEESE_SMD$ll_NHST[1],
                             model_est_PET_PEESE_SMD$ll_NHST[2],
                             model_est_PET_PEESE_SMD$ll_NHST[3],
                             model_est_PET_PEESE_SMD$ll_NHST[4],
                             model_est_PET_PEESE_SMD$ll_NHST[5],
                             model_est_PET_PEESE_SMD$ll_NHST[6],
                             model_est_SMD$ll_NHST[7],
                             model_est_SMD$ll_NHST[8],
                             model_est_PET_PEESE_SMD$ll_NHST[9],
                             model_est_SMD$ll_NHST[10],
                             model_est_SMD$ll_NHST[11],
                             model_est_PET_PEESE_SMD$ll_NHST[12]
                            ),
                
                  ul_NHST=c(model_est_PET_PEESE_SMD$ul_NHST[1],
                             model_est_PET_PEESE_SMD$ul_NHST[2],
                             model_est_PET_PEESE_SMD$ul_NHST[3],
                             model_est_PET_PEESE_SMD$ul_NHST[4],
                             model_est_PET_PEESE_SMD$ul_NHST[5],
                             model_est_PET_PEESE_SMD$ul_NHST[6],
                             model_est_SMD$ul_NHST[7],
                             model_est_SMD$ul_NHST[8],
                             model_est_PET_PEESE_SMD$ul_NHST[9],
                             model_est_SMD$ul_NHST[10],
                             model_est_SMD$ul_NHST[11],
                             model_est_PET_PEESE_SMD$ul_NHST[12]
                            ),
                
                  p_value=c(model_est_PET_PEESE_SMD$p_value[1],
                             model_est_PET_PEESE_SMD$p_value[2],
                             model_est_PET_PEESE_SMD$p_value[3],
                             model_est_PET_PEESE_SMD$p_value[4],
                             model_est_PET_PEESE_SMD$p_value[5],
                             model_est_PET_PEESE_SMD$p_value[6],
                             model_est_SMD$p_value[7],
                             model_est_SMD$p_value[8],
                             model_est_PET_PEESE_SMD$p_value[9],
                             model_est_SMD$p_value[10],
                             model_est_SMD$p_value[11],
                             model_est_PET_PEESE_SMD$p_value[12]
                            )) 

```



#### 2.3 Calculate meta-analysis level power, Type S and M

```{r}

# cope
dat_list_adjusted_SMD <- SMD

#-----------------------------------------------------------#
#          (1) two-tailed power for meta-analyses
#-----------------------------------------------------------#
model_est_adjusted_SMD$MA.power <- power.ma_Shinichi(mu=model_est_adjusted_SMD$mu,SE=model_est_adjusted_SMD$SE)


#-----------------------------------------------------------#
#            (2) type S error for meta-analyses
#-----------------------------------------------------------#
MA.power.S <- NA
for (i in 1:length(model_est_adjusted_SMD$MA_case)) {
  MA.power.S[i] <- error_S(mu=model_est_adjusted_SMD$mu[i],se=model_est_adjusted_SMD$SE[i],alpha=0.05) %>% unlist()
}

model_est_adjusted_SMD$MA.power.S <- MA.power.S


#-----------------------------------------------------------#
#   (3) type M error (overestimate ratio) for meta-analyses
#-----------------------------------------------------------#
MA.power.M <- NA
for (i in 1:length(model_est_adjusted_SMD$MA_case)) {
  MA.power.M[i] <- error_M(mu=model_est_adjusted_SMD$mu[i],se=model_est_adjusted_SMD$SE[i],alpha=0.05,N=10000) %>% unlist()
}

model_est_adjusted_SMD$MA.power.M <- MA.power.M


view(model_est_adjusted_SMD)
```


#### 2.5 Weighted regression on meta-analysis level data

```{r}

#***************************************************************#
#      estimate overall power for meta-analysis level power     #
#***************************************************************#

# add N and k
N_adjusted_SMD <- NA
for (i in 1:length(dat_list_adjusted_SMD)) {
  N_adjusted_SMD[i] <- dat_list_adjusted_SMD[[i]]$Study %>% unique() %>% length()
}

k_adjusted_SMD <- NA
for (i in 1:length(dat_list_adjusted_SMD)) {
  k_adjusted_SMD[i] <- dat_list_adjusted_SMD[[i]]$Unit_ID%>% length()
}

model_est_adjusted_SMD$k <- k_adjusted_SMD




#--------------------- (1) two tailed power ---------------------#
# log
MMA_MA_adjusted_SMD2 <- lm(log(MA.power)~1, weights = k, data = model_est_adjusted_SMD)
# this is median
MMA_MA_adjusted_SMD2$coefficients  %>% exp() 
#confidence interval of median
confint(MMA_MA_adjusted_SMD2) %>% exp()


#---------------------- (2) type S error -----------------------#
# log
MMA_MA.S_adjusted_SMD2 <- lm(log(MA.power.S+0.025) ~ 1, weights = k, data = model_est_adjusted_SMD) # +0.025(25%) to avoide ln(0) = infinity 
# this is median
MMA_MA.S_adjusted_SMD2$coefficients %>% exp() - 0.025
confint(MMA_MA.S_adjusted_SMD2) %>% exp() - 0.025 # if the lower boundary was negative (probably caused by the negative variance), we used 0 to replace it


#-------------- (3) type M error (overestimate ratio) -------------#
# log
MMA_MA.M_adjusted_SMD2 <- lm(log(MA.power.M)~1, weights = k, data = model_est_adjusted_SMD)
# this is median
MMA_MA.M_adjusted_SMD2$coefficients %>% exp() 
#confidence interval of median
confint(MMA_MA.M_adjusted_SMD2) %>% exp()
```





### 3. Adjusted SMD based on effective sample size

Now we to the same thing using effective sample size

#### 2.1 Estimate adjusted-SMD (effective sample size version)

Fit two-stage models and find meta-analyses with correct direction

```{r}

#***************************************************************#
#                       PET-PEESE approach                      #
#***************************************************************#

#----------------------------------------------------------------#
#              first-stage: using PET to model 'SE'                #
#----------------------------------------------------------------#

# creating a varible for the "effective sample size" to account for unbalanced sampling
# function to calculate effective sample size
esz <- function(dat){(4*dat$C_N*dat$T_N) / (dat$C_N + dat$T_N)}

 
esz_SMD <- NA
for (i in 1:length(SMD)) {
  esz_SMD[i] <- esz(SMD[[i]]) %>% list()}

# allocate each set of effective sample size into corresponding dataset
for (i in 1:length(SMD)) {
  SMD[[i]]$esz_SMD <- esz_SMD[[i]]
}
 

# creating inverse of sqrt of effective sample size - "effective sample size" based "sampling variance" 
## function to calculate inverse of sqrt of effective sample size
esz.var <- function(dat){ 1/dat$C_N + 1/dat$T_N}
esz.var_SMD <- NA
for (i in 1:length(SMD)) {
  esz.var_SMD[i] <- esz.var(SMD[[i]]) %>% list()}

# allocate into corresponding dataset
for (i in 1:length(SMD)) {
  SMD[[i]]$esz.var_SMD <- esz.var_SMD[[i]]
}


# fit first stage model - inverse of effective sample size as moderator
model_list_PET_PEESE_SMD.sei.esz <- list() 
for (i in 1:length(SMD)) {
 model_list_PET_PEESE_SMD.sei.esz[i] <- rma.mv(data = SMD[[i]], yi = yi, V = vi, mods = ~ sqrt(esz.var_SMD),random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}

# get intercepts and slopes for first stage
## intercepts
model_est_PET_PEESE_SMD.sei.esz.intercept <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$beta[1]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$se[1]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$ci.lb[1]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$ci.ub[1]),
                  p_value=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$pval)[c(seq(1,24,2))]) # odd columns for intercept's p-value

## slopes
model_est_PET_PEESE_SMD.sei.esz.slope <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$beta[2]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$se[2]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$ci.lb[2]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$ci.ub[2]),
                  p_value=sapply(model_list_PET_PEESE_SMD.sei.esz, function(x) x$pval)[c(seq(2,24,2))]) # even columns for slope's p-value



#----------------------------------------------------------------#
#           second-stage: using PEESE to model 'variance'          #
#----------------------------------------------------------------#

# fit second stage model - sampling variance as moderator
model_list_PET_PEESE_SMD.var.esz <- list() 
for (i in 1:12) {
 model_list_PET_PEESE_SMD.var.esz[i] <- rma.mv(data = SMD[[i]], yi = yi, V = vi, mods = ~ esz.var_SMD, random = list(~1|Study, ~1|Unit_ID), method = "REML", test = "t") %>% list()
}


# get intercepts and slopes for second stage
## intercepts
model_est_PET_PEESE_SMD.var.esz.intercept <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$beta[1]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$se[1]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$ci.lb[1]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$ci.ub[1]),
                  p_value=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$pval)[c(seq(1,24,2))]) # odd columns for intercept's p-value


## slopes
model_est_PET_PEESE_SMD.var.esz.slope <- data.frame(MA_case=model_est_SMD$MA_case,
                  mu_SMD=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$beta[2]),
                  SE_SMD=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$se[2]),
                  ll_NHST=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$ci.lb[2]),
                  ul_NHST=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$ci.ub[2]),
                  p_value=sapply(model_list_PET_PEESE_SMD.var.esz, function(x) x$pval)[c(seq(2,24,2))]) # odd columns for slope's p-value




#***************************************************************#
#           find meta-analyses with correct direction           #
#***************************************************************#

# using PET’s intercept ('se' as moderator) when slope is not sig but PEEESE’s intercept ('variance' or 'se^2' as moderator) if PET’s slope is sig
## label for reorder later
model_est_PET_PEESE_SMD.sei.esz.intercept$id <- c(1:12)
model_est_PET_PEESE_SMD.sei.esz.slope$id <- c(1:12)
model_est_PET_PEESE_SMD.var.esz.intercept$id <- c(1:12)
model_est_PET_PEESE_SMD.var.esz.slope$id <- c(1:12)

## significant slope
model_est_PET_PEESE_SMD.sei.esz.slope.sig <- model_est_PET_PEESE_SMD.sei.esz.slope %>% subset(p_value < 0.05) 
## non-significant slope
model_est_PET_PEESE_SMD.sei.esz.slope.nonsig <- model_est_PET_PEESE_SMD.sei.esz.slope %>% subset(p_value > 0.05)

## get location of PET's sig slope and non-sig slope, respectively
location.sig <- which(model_est_PET_PEESE_SMD.sei.esz.slope$p_value < 0.05)
location.nonsig <- which(model_est_PET_PEESE_SMD.sei.esz.slope$p_value > 0.05)


# get the intercept from PEESE (when PET’s slope is sig) and PET (when PET’s slope is nonsig)
model_est_PET_PEESE_SMD.esz <- rbind(model_est_PET_PEESE_SMD.sei.esz.intercept[location.nonsig,],model_est_PET_PEESE_SMD.var.esz.intercept[location.sig,]) 

# reorder according to the sequences of meta-analyses
model_est_PET_PEESE_SMD.esz <- model_est_PET_PEESE_SMD.esz[order(model_est_PET_PEESE_SMD.esz$id),] 


# obtain absolute values for making paired-comparision plot (see below)
model_est_PET_PEESE_SMD.esz2 <- model_est_PET_PEESE_SMD.esz
model_est_PET_PEESE_SMD.esz2$mu_SMD <- abs(model_est_PET_PEESE_SMD.esz$mu_SMD)

model_est_SMD2 <- model_est_SMD
model_est_SMD2$mu_SMD <- abs(model_est_SMD$mu_SMD)

# using dabestr package to creat a table for paired comparision of meta-analytic overall estimate (MAOM) and bias-corrected estimate (cMAOM)
dummy <- rep("Dummy", 12)
wide.data <- 
  tibble::tibble(
    MAOM = model_est_SMD2$mu_SMD,
    cMAOM = model_est_PET_PEESE_SMD.esz2$mu_SMD,
    Dummy = dummy, ID = 1:12, MA_case = model_est_PET_PEESE_SMD.esz2$MA_case)

## find correct direction of slope
include.point <- which((wide.data$cMAOM - wide.data$MAOM)<0)
## table only includes correct data
wide.data3 <- wide.data[include.point,]

## make paired comparision plot 
my.data3 <- 
  wide.data3 %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Dummy, -MA_case)

two.group.paired3 <- 
  my.data3 %>%
  dabest(Group, Measurement, 
         idx = c("MAOM", "cMAOM"), 
         paired = TRUE, id.col = ID)

paired.plot3_SMD.esz <- two.group.paired3 %>% 
  mean_diff() %>% 
  plot(#rawplot.ylim = c(-2, 1),
       #effsize.ylim = c(-2, 1),
       #rawplot.markersize = 1,
       #rawplot.groupwidth = 0.4,
      rawplot.ylabel = "Meta-analytic estimate (SMD.esz)",
      effsize.ylabel = "Mean differences (bootstrap resampling)",
      axes.title.fontsize = 14, # default is 14
      palette = c("Dark2")
      )

png(filename = "./Figures/paired.plot3_SMD.esz.png", width = 5, height = 4, units = "in", type = "windows", res = 400)
paired.plot3_SMD.esz
dev.off()

```



#### 2.2 Compile datasets for adjusted SMD

When using sampling variance (or SE) as moderator, we had 4 meta-analyses showing the correct direction slope. For the left 8, I we used the original meta-analytic overall mean


```{r}

# get estimates from bias-corrected models (model_est_PET_PEESE_SMD) if in a correct direction of slope. Otherwise it should use estimates from original models (model_est_SMD). 

# view(my.data3) or my.data3$ID can know those from bias-corrected models: 1, 3, 4, 11
# get corresponding estimates
model_est_adjusted_SMD.esz <- data.frame(MA_case=model_est_PET_PEESE_SMD$MA_case,
                    mu_SMD=c(model_est_PET_PEESE_SMD.esz$mu_SMD[1], # match with the my.data3$ID; also see 3, 4, 11
                             model_est_SMD$mu_SMD[2], 
                             model_est_PET_PEESE_SMD.esz$mu_SMD[3], 
                             model_est_PET_PEESE_SMD.esz$mu_SMD[4],
                             model_est_SMD$mu_SMD[5],
                             model_est_SMD$mu_SMD[6],
                             model_est_SMD$mu_SMD[7],
                             model_est_SMD$mu_SMD[8],
                             model_est_SMD$mu_SMD[9],
                             model_est_SMD$mu_SMD[10],
                             model_est_PET_PEESE_SMD.esz$mu_SMD[11],
                             model_est_SMD$mu_SMD[12]
                            ),
                    
                    SE_SMD=c(model_est_PET_PEESE_SMD.esz$SE_SMD[1],
                             model_est_SMD$SE_SMD[2], 
                             model_est_PET_PEESE_SMD.esz$SE_SMD[3], 
                             model_est_PET_PEESE_SMD.esz$SE_SMD[4],
                             model_est_SMD$SE_SMD[5],
                             model_est_SMD$SE_SMD[6],
                             model_est_SMD$SE_SMD[7],
                             model_est_SMD$SE_SMD[8],
                             model_est_SMD$SE_SMD[9],
                             model_est_SMD$SE_SMD[10],
                             model_est_PET_PEESE_SMD.esz$SE_SMD[11],
                             model_est_SMD$SE_SMD[12]
                            ),
                    
                ll_NHST=c(model_est_PET_PEESE_SMD.esz$ll_NHST[1],
                             model_est_SMD$ll_NHST[2], 
                             model_est_PET_PEESE_SMD.esz$ll_NHST[3], 
                             model_est_PET_PEESE_SMD.esz$ll_NHST[4],
                             model_est_SMD$ll_NHST[5],
                             model_est_SMD$ll_NHST[6],
                             model_est_SMD$ll_NHST[7],
                             model_est_SMD$ll_NHST[8],
                             model_est_SMD$ll_NHST[9],
                             model_est_SMD$ll_NHST[10],
                             model_est_PET_PEESE_SMD.esz$ll_NHST[11],
                             model_est_SMD$ll_NHST[12]
                            ),
                
                  ul_NHST=c(model_est_PET_PEESE_SMD.esz$ul_NHST[1],
                             model_est_SMD$ul_NHST[2], 
                             model_est_PET_PEESE_SMD.esz$ul_NHST[3], 
                             model_est_PET_PEESE_SMD.esz$ul_NHST[4],
                             model_est_SMD$ul_NHST[5],
                             model_est_SMD$ul_NHST[6],
                             model_est_SMD$ul_NHST[7],
                             model_est_SMD$ul_NHST[8],
                             model_est_SMD$ul_NHST[9],
                             model_est_SMD$ul_NHST[10],
                             model_est_PET_PEESE_SMD.esz$ul_NHST[11],
                             model_est_SMD$ul_NHST[12]
                            ),
                
                  p_value=c(model_est_PET_PEESE_SMD.esz$p_value[1],
                             model_est_SMD$p_value[2], 
                             model_est_PET_PEESE_SMD.esz$p_value[3], 
                             model_est_PET_PEESE_SMD.esz$p_value[4],
                             model_est_SMD$p_value[5],
                             model_est_SMD$p_value[6],
                             model_est_SMD$p_value[7],
                             model_est_SMD$p_value[8],
                             model_est_SMD$p_value[9],
                             model_est_SMD$p_value[10],
                             model_est_PET_PEESE_SMD.esz$p_value[11],
                             model_est_SMD$p_value[12]
                            )) 

```



#### 2.3 Calculate meta-analysis level power, Type S and M

```{r}



#-----------------------------------------------------------#
#          (1) two-tailed power for meta-analyses
#-----------------------------------------------------------#
model_est_adjusted_SMD.esz$MA.power <- power.ma_Shinichi(mu=model_est_adjusted_SMD.esz$mu,SE=model_est_adjusted_SMD.esz$SE)


#-----------------------------------------------------------#
#            (2) type S error for meta-analyses
#-----------------------------------------------------------#
MA.power.S <- NA
for (i in 1:length(model_est_adjusted_SMD.esz$MA_case)) {
  MA.power.S[i] <- error_S(mu=model_est_adjusted_SMD.esz$mu[i],se=model_est_adjusted_SMD.esz$SE[i],alpha=0.05) %>% unlist()
}

model_est_adjusted_SMD.esz$MA.power.S <- MA.power.S


#-----------------------------------------------------------#
#   (3) type M error (overestimate ratio) for meta-analyses
#-----------------------------------------------------------#
MA.power.M <- NA
for (i in 1:length(model_est_adjusted_SMD.esz$MA_case)) {
  MA.power.M[i] <- error_M(mu=model_est_adjusted_SMD.esz$mu[i],se=model_est_adjusted_SMD.esz$SE[i],alpha=0.05,N=10000) %>% unlist()
}

model_est_adjusted_SMD.esz$MA.power.M <- MA.power.M


view(model_est_adjusted_SMD.esz)
```


#### 2.5 Weighted regression on meta-analysis level data

```{r}

#***************************************************************#
#      estimate overall power for meta-analysis level power     #
#***************************************************************#

# add N and k
N_adjusted_SMD <- NA
for (i in 1:length(dat_list_adjusted_SMD)) {
  N_adjusted_SMD[i] <- dat_list_adjusted_SMD[[i]]$Study %>% unique() %>% length()
}

k_adjusted_SMD <- NA
for (i in 1:length(dat_list_adjusted_SMD)) {
  k_adjusted_SMD[i] <- dat_list_adjusted_SMD[[i]]$Unit_ID%>% length()
}

model_est_adjusted_SMD.esz$k <- k_adjusted_SMD




#--------------------- (1) two tailed power ---------------------#
# log
MMA_MA_adjusted_SMD.esz2 <- lm(log(MA.power)~1, weights = k, data = model_est_adjusted_SMD.esz)
# this is median
MMA_MA_adjusted_SMD.esz2$coefficients  %>% exp() 
#confidence interval of median
confint(MMA_MA_adjusted_SMD.esz2) %>% exp()


#---------------------- (2) type S error -----------------------#
# log
MMA_MA.S_adjusted_SMD.esz2 <- lm(log(MA.power.S+0.025) ~ 1, weights = k, data = model_est_adjusted_SMD.esz) # +0.025(25%) to avoide ln(0) = infinity 
# this is median
MMA_MA.S_adjusted_SMD.esz2$coefficients %>% exp() - 0.025
confint(MMA_MA.S_adjusted_SMD.esz2) %>% exp() - 0.025 # if the lower boundary was negative (probably caused by the negative variance), we used 0 to replace it


#-------------- (3) type M error (overestimate ratio) -------------#
# log
MMA_MA.M_adjusted_SMD.esz2 <- lm(log(MA.power.M)~1, weights = k, data = model_est_adjusted_SMD.esz)
# this is median
MMA_MA.M_adjusted_SMD.esz2$coefficients %>% exp() 
#confidence interval of median
confint(MMA_MA.M_adjusted_SMD.esz2) %>% exp()
```






